\documentclass[a4paper,twoside]{scrartcl}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{amsthm}
\usepackage{amsfonts}
%\usepackage{cases}
\usepackage[english]{babel}
%\usepackage{upgreek}
\usepackage[pdftex]{graphicx}
\usepackage[utf8]{inputenc}
\numberwithin{equation}{section}
\usepackage{subfig}
\usepackage{color}
\usepackage{fullpage} % install texlive-latex-extra
\usepackage[pdftex,bookmarks]{hyperref}%pdf support

\usepackage{thumbpdf}% PDF Thumbnails erstellen
%\usepackage{captcont}
%\usepackage{bbding}
%\usepackage{nomencl}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue
}
\newcommand{\hmeth}[1]{\hyperref[sec:#1]{#1}}
\newcommand{\hhmeth}[2]{\hyperref[sec:#2:#1]{#1}}
\newcommand{\hhhmeth}[3]{\hyperref[sec:#2:#1]{#3}}
\newcommand{\param}[1]{\textbf{#1}}

\newcommand{\eg}{\textit{e.g.}\xspace}

\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=single,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=2
}
\newcommand{\lcode}[1]{\lstinline$#1$}
%\lstset{language=Python, frame=single}

\usepackage{color} 
\definecolor{darkgreen}{RGB}{0,128,0}% for example

\usepackage{xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\renewcommand{\d}{\mathrm{d}}


%\renewcommand{\nomname}{Keywords}
\def\titlestr{User Manual}
\def\subtitlestr{Ifasha (version 0.3)}
\def\authorstr{David S. Kammer}
\hypersetup{
pdftitle={\titlestr (\subtitlestr)},
pdfauthor={\authorstr},
pdfkeywords={user manual, data post-processing, python library},
pdfstartview=FitH,
pdffitwindow=false,
pdfduplex=DuplexFlipLongEdge,
pdfdisplaydoctitle=true}

\title{\titlestr }
\subtitle{\subtitlestr }
\author{\authorstr\\davekammer@gmail.com}

\date{\today}
%\makenomenclature

\begin{document}
\maketitle

\tableofcontents

\section{How to Start}
\label{sec:howtostart}

This code can be used to 
\begin{enumerate}
\item post-process data that was dumped by IOHelper during simulations within Akantu, 
\item access efficiently data that was post-processed,
\item compute analytic solutions of solid mechanics and fracture mechanics (LEFM).
\end{enumerate} 
%You can checkout the source from the following location of the intranet-lsms:
%\begin{lstlisting}[language=sh]
%  /space/repositories/SimulPack/users/kammer/dev/scripts/dsk_python_lib
%\end{lstlisting}
By adding the new directory to the python path, you can use the method everywhere on your system. On possibility is to add the following line to your \emph{.bashrc} file.
\begin{lstlisting}[language=sh]
export PYTHONPATH=$PYTHONPATH:/home/user/sources 
\end{lstlisting}%$
and then put entire ifasha into the \emph{sources} folder.

\section{FieldId}
\label{sec:FieldId}

The \hmeth{FieldId} is the way an output field is identified. It needs the following information:
\begin{itemize}
  \item name: 
    \begin{itemize}
      \item \textit{description}: the field's name, as given by the simulation
    \end{itemize}
  \item dir:
    \begin{itemize}
      \item \textit{description}: the direction of the field. x=0, y=1, z=2
      %\item \textit{default}: x=0, fields that do not have a direction (\eg kinetic energy) use this default value.
    \end{itemize}
\end{itemize}

\begin{lstlisting}
  from ifasha.datamanager import FieldId
  fid = FieldId(name, 0)
\end{lstlisting}

The time fields are global fields and currently there are: \lcode{step} and \lcode{time}



\section{DataManager}
\label{sec:DataManager}

This is the base class that handles multiple data output of a single simulation. The inherited class \hmeth{DataManagerAnalysis} can be used to access data for further analysis. 

\subsection{init}
\label{sec:dm:init}
The \hmeth{DataManager} is created by providing its name.
\begin{lstlisting}
  from ifasha.datamanager import DataManager
  dm = DataManager(name, [path='./'], [create=False])
\end{lstlisting}
\begin{itemize}
  \item \param{name}: name of simulation to be loaded
  \item \param{path}: path to where the simulation is saved (default value = './')
  \item \param{create}: if data does not exist, should it be created?
\end{itemize}

\subsection{destroy}
\label{sec:dm:destroy}
This destroys all data corresponding to this \hmeth{DataManager}.
\begin{lstlisting}
  dm.destroy()
\end{lstlisting}

\subsection{get\_field\_collection}
\label{sec:dm:get_field_collection}
Returns a \hmeth{FieldCollection} object of data contained in the present \hmeth{DataManager}.
\begin{lstlisting}
  from ifasha.datamanager import FieldCollection
  fc = dm.get_field_collection(name)
\end{lstlisting}
\begin{itemize}
\item \param{name}: name of \hmeth{FieldCollection} to be returned
\end{itemize}

\subsection{get\_new\_field\_collection}
\label{sec:dm:get_new_field_collection}
Creates a new \hmeth{FieldCollection} in the \hmeth{DataManager} and returns it.
\begin{lstlisting}
  from ifasha.datamanager import FieldCollection
  fc = dm.get_new_field_collection(name)
\end{lstlisting}
\begin{itemize}
\item \param{name}: name of \hmeth{FieldCollection} to be created and returned.
\end{itemize}
If a \hmeth{FieldCollection} with the same name exists already, it will raise a RuntimeError. 

\subsection{remove\_field\_collection}
\label{sec:dm:remove_field_collection}
Removes a \hmeth{FieldCollection} from the \hmeth{DataManager} and destroys it.
\begin{lstlisting}
  dm.remove_field_collection{name}
\end{lstlisting}
\begin{itemize}
  \item \param{name}: name of \hmeth{FieldCollection} to be removed and destroyed.
\end{itemize}

\subsection{add\_supplementary}
\label{sec:dm:add_supplementary}
Add an supplementary file with auxiliary information (\textit{e.g.,} input file or output file)
\begin{lstlisting}
  dm.add_supplementary(fname, path, [replace=False])
\end{lstlisting}
\begin{itemize}
\item \param{fname}: name to be given to the file stored into this \hmeth{DataManager}
\item \param{path}: path to file that will be copied into the \hmeth{DataManager}
\item \param{replace}: should it be replaced, if a file with same \emph{fname} exists already?
\end{itemize}

\subsection{remove\_supplementary}
\label{sec:dm:remove_supplementary}
Remove a supplementary file from the \hmeth{DataManager}
\begin{lstlisting}
  dm.remove_supplementary(fname)
\end{lstlisting}
\begin{itemize}
  \item \param{fname}: name of file to be removed
\end{itemize}
If file does not exist, this method does nothing.


\subsection{Examples}
\label{sec:dm:examples}
-To do.

\section{DataManagerAnalysis}
\label{sec:DataManagerAnalysis}

This class adds a method to the \hmeth{DataManager} that helps you to get a \hmeth{FieldCollectionAnalysis} object.

\subsection{init}
\label{sec:dma:init}
Similar to the \hmeth{DataManager}, this initiates an object. The main difference is that it does not create a new object, if none with the provided name exists. This is to avoid the creating of new object by mistake (because you don't know how to write the name of your data).
\begin{lstlisting}
  from ifasha.datamanager import DataManagerAnalysis
  dma = DataManagerAnalysis(name, [path='./'])
\end{lstlisting}
\begin{itemize}
  \item \param{name}: name of simulation to be loaded
  \item \param{path}: path to where the simulation is saved (default value = './')
\end{itemize}

\subsection{operator()}
\label{sec:dma:op}
This operator provides you with the possibility of getting a \hmeth{FieldCollectionAnalysis} object from the \hmeth{DataManagerAnalysis}.
\begin{lstlisting}
  fca = dma(name)
\end{lstlisting}
\begin{itemize}
\item \param{name}: name of \hmeth{FieldCollection} you would like to access as a \hmeth{FieldCollectionAnalysis} object.
\end{itemize}


\section{FieldCollectionAnalysis}
\label{sec:FieldCollectionAnalysis}

The \hmeth{FieldCollectionAnalysis} helps to extract data from the \hmeth{DataManager} in order to plot and analysis it. It inherits all methods from \hmeth{FieldCollection}. See \hhmeth{init}{dma} for how to get an instant from the \hmeth{DataManagerAnalysis}.

Different methods exist to access data: 
\begin{itemize}
\item full field: \hhhmeth{get_full_field}{fca}{get\_full\_field} 
\item at a time: \hhhmeth{get_field_at_t}{fca}{get\_field\_at\_t}, \hhhmeth{get_t_index}{fca}{get\_t\_index}, \hhhmeth{get_index_of_closest_time}{fca}{get\_index\_of\_closest\_time}, \hhhmeth{get_field_at_t_index}{fca}{get\_field\_at\_t\_index}
\item at a position: \hhhmeth{get_index_of_closest_position}{fca}{get\_index\_of\_closest\_position}, \hhhmeth{get_field_at_node_index}{fca}{get\_field\_at\_node\_index}
\item 2d plot: \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot}, \hhhmeth{get_sliced_x_y_plot}{fca}{get\_sliced\_x\_y\_plot}, \hhhmeth{get_nb_points_in_direction}{fca}{get\_nb\_points\_in\_direction}, \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}, \hhhmeth{get_sliced_x_t_plot}{fca}{get\_sliced\_x\_t\_plot}
\end{itemize}

\subsection{get\_full\_field}
\label{sec:fca:get_full_field}
Returns the MemMap of the field. 
For nodal and elemental fields, the first dimension is the index of time and the second dimension the index of the node/element. For global fields (\eg step, time), there is only the first dimension for the time index and no second dimension exists.
\begin{lstlisting}
  fmmap = fca.get_full_field(fldid)
\end{lstlisting}
\begin{itemize}
  \item \param{fldid}: \hmeth{FieldId} of the field
  \item \param{fmmap}: MemMap with data. 
    \begin{itemize}
      \item nodal/elemental field: \lcode{fmmap[tindex,xindex]} with the time index \lcode{tindex} and the node/element index \lcode{xindex}
      \item global field: \lcode{fmmap[tindex]} with the time index \lcode{tindex} 
    \end{itemize}
\end{itemize}

\subsection{get\_field\_at\_t}
\label{sec:fca:get_field_at_t}
Returns an array of the field as close to a given time, where the time can also be a step.
\begin{lstlisting}
  farray = data.get_field_at_t(fldid, tid, ts)
\end{lstlisting}
\begin{itemize}
  \item \param{fldid}: \hmeth{FieldId} of the field. 
  \item \param{tid}: \hmeth{FieldId} of the time field. Depending on whether \lcode{ts} are a times or a time steps. 
  \item \param{ts}: list of time steps or times
  \item \param{farray}: array of the fields at the times, see \hhhmeth{get_field_at_t_index}{fca}{get\_field\_at\_t\_index}. 
\end{itemize}

\subsection{get\_t\_index}
\label{sec:fca:get_t_index}
Returns a time index or a list of time indexes for a given indicator or list of indicators.
\begin{lstlisting}
  idxs = fca.get_t_index(inds)
\end{lstlisting}
\begin{itemize}
  \item \param{inds}: an indicator or a list of indicators. Currently there are: \lcode{"first" "middle" "last"}
  \item \param{idxs}: time index or list of time indexes, depending whether \lcode{inds} is a list.
\end{itemize}

\subsection{get\_index\_of\_closest\_time}
\label{sec:fca:get_index_of_closest_time}
Returns a time index or a list of time indexes for a given time field (\eg \lcode{step}, \lcode{time}) and a ``time'' or list of ``times''.
\begin{lstlisting}
  idxs = fca.get_index_of_closest_time(fldid, tms)
\end{lstlisting}
\begin{itemize}
  \item \param{fldid}: \hmeth{FieldId} of any time field
  \item \param{tms}: time/step or list of times/steps
  \item \param{idxs}: time index or list of time indexes, depending whether \lcode{tms} is a list.
\end{itemize}

\subsection{get\_field\_at\_t\_index}
\label{sec:fca:get_field_at_t_index}
Returns an array of the field at the given indexes.
\begin{lstlisting}
  farray = fca.get_field_at_t_index(fldid, idxs)
\end{lstlisting}
\begin{itemize}
  \item \param{fldid}: \hmeth{FieldId} of the field
  \item \param{idxs}: list of time indexes
  \item \param{farray}: array of field 
    \begin{itemize}
    \item nodal/elemental field: \lcode{farray[i,xindex]}
    \item global field: \lcode{farray[i]}
    \end{itemize}
    with \lcode{i} the index of the time index in the \lcode{idxs} list, and \lcode{xindex} the index of the node/element.
\end{itemize}

\subsection{get\_index\_of\_closest\_position}
\label{sec:fca:get_index_of_closest_position}
Returns the index of the closest node for a given point.
\begin{lstlisting}
  idx = fca.get_index_of_closest_position(fldids, vlus)
\end{lstlisting}
\begin{itemize}
  \item \param{fldids}: list of \hmeth{FieldId}. 
  \item \param{vlus}: list of values of the position 
  \item \param{idx}: node index of closest node 
\end{itemize}
This method uses the first (in time) entry of the given field. Considering this is the position, which does not change. It cannot find the closest position at a position for a later point.

Example for finding a node that is closest to the point $x=3.$ and $y=5.$:
\begin{lstlisting}
  idx = fca.get_index_of_closest_position([FieldId("position",0),
                                               FieldId("position",1)],[3.,5.])
\end{lstlisting}

\subsection{get\_field\_at\_node\_index}
\label{sec:fca:get_field_at_node_index}
Returns the field for a list of given nodes indicated by their indexes.
\begin{lstlisting}
  farray = fca.get_field_at_node_index(fldid, idxs)
\end{lstlisting}
\begin{itemize}
  \item \param{fldid}: \hmeth{FieldId} of the field
  \item \param{idxs}: list of node indexes
  \item \param{farray}: array of the field with \lcode{farray[tindex,i]} where \lcode{tindex} is the time index and \lcode{i} is the index of the node indexes in the \lcode{idxs} list.
\end{itemize}

\subsection{get\_nb\_points\_in\_direction}
\label{sec:fca:get_nb_points_in_direction}
Returns the number of points for a 2D plot in the direction of the field position field provided.
\begin{lstlisting}
  nbpts = fca.get_nb_points_in_direction(xfldid,tidx)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the position field
  \item \param{tidx}: time index (with default value = 0)
  \item \param{nbpts}: number of points in the direction of the position field
\end{itemize}

\subsection{get\_x\_y\_plot}
\label{sec:fca:get_x_y_plot}
Returns three MemMaps that can be used to plot as a 2D color plot.
\begin{lstlisting}
  X,Y,Z = fca.get_x_y_plot(xfldid, yfldid, zfldid, tidx)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{yfldid}: \hmeth{FieldId} of the Y field
  \item \param{zfldid}: \hmeth{FieldId} of the Z field
  \item \param{tidx}: time index
  \item \param{X,Y,Z}: MemMaps that can be used for 2D color plots.
\end{itemize}
For an example see \hhhmeth{get_sliced_x_sliced_y_plot}{fca}{get\_sliced\_x\_sliced\_y\_plot}.

\subsection{get\_sliced\_x\_sliced\_y\_plot}
\label{sec:fca:get_sliced_x_sliced_y_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot}) where X and Y are sliced.
\begin{lstlisting}
  X,Y,Z = fca.get_x_y_plot(xfldid, xslice, yfldid, yslice, zfldid, tidx)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{xslice}: slices in X direction 
  \item \param{yfldid}: \hmeth{FieldId} of the Y field
  \item \param{yslice}: slices in Y direction 
  \item \param{zfldid}: \hmeth{FieldId} of the Z field
  \item \param{tidx}: time index
  \item \param{X,Y,Z}: MemMaps that can be used for 2D color plots.
\end{itemize}
Example showing how to use this method:
\begin{lstlisting}
  #!/usr/bin/env python

  import matplotlib.pyplot as plt
  import numpy as np
  from mpl_toolkits.mplot3d import axis3d

  X,Y,Z = fca.get_sliced_x_sliced_y_plot(FieldId("position",0),
                                             np.arange(0,201,2),
                                             FieldId("position",1),
                                             np.arange(1,21,3),
                                             FieldId("velocity",0))

  fig = plt.figure()
  ax = fig.add_subplot(111)
  ax.pcolor(X,Y,Z)
  plt.show()
\end{lstlisting}

\subsection{get\_sliced\_x\_y\_plot}
\label{sec:fca:get_sliced_x_y_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot}) where X is sliced.
\begin{lstlisting}
  X,Y,Z = fca.get_sliced_x_y_plot(xfldid, xslice, yfldid, zfldid, tidx)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{xslice}: slices in X direction 
  \item \param{yfldid}: \hmeth{FieldId} of the Y field
  \item \param{zfldid}: \hmeth{FieldId} of the Z field
  \item \param{tidx}: time index
  \item \param{X,Y,Z}: MemMaps that can be used for 2D color plots.
\end{itemize}

\subsection{get\_x\_sliced\_y\_plot}
\label{sec:fca:get_x_sliced_y_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot}) where Y is sliced.
\begin{lstlisting}
  X,Y,Z = fca.get_x_sliced_y_plot(xfldid, yfldid, yslice, zfldid, tidx)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{yfldid}: \hmeth{FieldId} of the Y field
  \item \param{yslice}: slices in Y direction 
  \item \param{zfldid}: \hmeth{FieldId} of the Z field
  \item \param{tidx}: time index
  \item \param{X,Y,Z}: MemMaps that can be used for 2D color plots.
\end{itemize}

\subsection{get\_x\_t\_plot}
\label{sec:fca:get_x_t_plot}
Returns three MemMaps that can be used to plot as a 2D color plot. This works only for one dimensional data.
\begin{lstlisting}
  X,T,V = fca.get_x_t_plot(xfldid, tfldid, vfldid)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{tfldid}: \hmeth{FieldId} of the time field T
  \item \param{vfldid}: \hmeth{FieldId} of the V field
  \item \param{X,T,V}: MemMaps that can be used for 2D space-time color plots
\end{itemize}
For an example see: \hhhmeth{get_sliced_x_sliced_t_plot}{fca}{get\_sliced\_x\_sliced\_t\_plot}

\subsection{get\_sliced\_x\_sliced\_t\_plot}
\label{sec:fca:get_sliced_x_sliced_t_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}) where X and T are sliced. This works only for one dimensional data.
\begin{lstlisting}
  X,T,V = fca.get_sliced_x_sliced_t_plot(xfldid, xslice, tfldid, tslice, vfldid)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{xslice}: slices in X direction
  \item \param{tfldid}: \hmeth{FieldId} of the time field T
  \item \param{tslice}: slices in time T 
  \item \param{vfldid}: \hmeth{FieldId} of the V field
  \item \param{X,T,V}: MemMaps that can be used for 2D space-time color plots
\end{itemize}

Example showing how to use this method:
\begin{lstlisting}
  #!/usr/bin/env python

  import matplotlib.pyplot as plt
  import numpy as np
  from mpl_toolkits.mplot3d import axis3d

  X,T,Z = data.get_sliced_x_sliced_t_plot(FieldId("position",0),
                                              np.arange(0,201,2),
                                              FieldId("time"),
                                              np.arange(1,1000,10),
                                              FieldId("velocity",0))

  fig = plt.figure()
  ax = fig.add_subplot(111)
  ax.pcolor(X,T,Z)
  plt.show()
\end{lstlisting}

\subsection{get\_sliced\_x\_t\_plot}
\label{sec:fca:get_sliced_x_t_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see  \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}) where X is sliced. This works only for one dimensional data.
\begin{lstlisting}
  X,T,V = fca.get_sliced_x_t_plot(xfldid, xslice, tfldid, vfldid)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{xslice}: slices in X direction
  \item \param{tfldid}: \hmeth{FieldId} of the time field T
  \item \param{vfldid}: \hmeth{FieldId} of the V field
  \item \param{X,T,V}: MemMaps that can be used for 2D space-time color plots
\end{itemize}


\subsection{get\_x\_sliced\_t\_plot}
\label{sec:fca:get_x_sliced_t_plot}
Returns three MemMaps that can be used to plot as a 2D color plot (see  \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}) where T is sliced. This works only for one dimensional data.
\begin{lstlisting}
  X,T,V = fca.get_x_sliced_t_plot(xfldid, tfldid, tslice, vfldid)
\end{lstlisting}
\begin{itemize}
  \item \param{xfldid}: \hmeth{FieldId} of the X field
  \item \param{tfldid}: \hmeth{FieldId} of the time field T
  \item \param{tslice}: slices in time T 
  \item \param{vfldid}: \hmeth{FieldId} of the V field
  \item \param{X,T,V}: MemMaps that can be used for 2D space-time color plots
\end{itemize}

\subsection{make\_it\_pretty}
\label{sec:fca:make_it_pretty}
This is a static method which improves the X,Y or X,T matrices for pretty plots. The shape of the matrices is increased in both dimension by one and values are changed such that colour plots have squares with the centre position of the value
\begin{lstlisting}
  Xp, Yp = FieldCollectionAnalysis.make_it_pretty(X,Y)
\end{lstlisting}
\begin{itemize}
  \item \param{X}: X MemMap from \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot} or \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}.
  \item \param{Y}: Y MemMap from \hhhmeth{get_x_y_plot}{fca}{get\_x\_y\_plot} or T MemMap from \hhhmeth{get_x_t_plot}{fca}{get\_x\_t\_plot}
  \item \param{Xp}: X MemMap for pretty plot
  \item \param{Yp}: Y MemMap for pretty plot
\end{itemize}
Do not use values in Xp and Yp for computation, only for pretty plots!

\subsection{Examples}
\label{sec:fca:Examples}

Plot global variables:
\begin{lstlisting}
  #!/usr/bin/env python

  from ifasha.datamanager import FieldId
  from ifasha.datamanager import DataManagerAnalysis
  from ifasha.datamanager import FieldCollectionAnalysis

  import matplotlib.pyplot as plt

  # location of simulation data
  sim_name = "test"
  fc_name = "global"
  path = "/home/researcher/post_process"

  # load the simulation data
  dma = DataManagerAnalysis(sim_name,path)
  fca = dma(fc_name)

  # get time as well as kinetic and potential energy (all global variables)
  time = fca.get_full_field(FieldId("time"))
  Ekin = fca.get_full_field(FieldId("kinetic_energy"))
  Epot = fca.get_full_field(FieldId("potential_energy"))

  # prepare plot
  fig = plt.figure()
  ax = fig.add_subplot(111)

  # plot energies w.r.t. time
  ax.plot(time, Ekin, ".-", label="kinetic energy")
  ax.plot(time, Epot, ".-", label="potential energy")
  ax.plot(time, Ekin+Epot, ".-", label="total energy")
  
  # finalize plot
  ax.set_xlabel(r"time $t$ (s)")
  ax.set_ylabel(r"energy $E$ (GJ)")
  ax.legend()

  plt.show()
\end{lstlisting}

Plot data on a boundary at a given time:
\begin{lstlisting}
  #!/usr/bin/env python


  from ifasha.datamanager import FieldId
  from ifasha.datamanager import DataManagerAnalysis
  from ifasha.datamanager import FieldCollectionAnalysis

  import matplotlib.pyplot as plt

  # location of simulation data
  sim_name = "test"
  fc_name = "global"
  path = "/home/researcher/post_process"

  # load the simulation data
  dma = DataManagerAnalysis(sim_name,path)
  fca = dma(fc_name)

  # define time at which to plot
  time_t = 0.1
  tfld = FieldId("time")
  tidx = fca.get_index_of_closest_time(tfld,time_t)

  # get position in x and velocity in x and y
  positionX = fca.get_field_at_t_index(FieldId("position",0),tidx)
  velocityX = fca.get_field_at_t_index(FieldId("velocity",0),tidx)
  velocityY = fca.get_field_at_t_index(FieldId("velocity",1),tidx)

  # sort all fields together w.r.t. the position x
  # the 0 indicates that this is for the first time (tidx) given above
  # tidx could be a list: there would be more than one entry in the first dimension
  fltr = positionX.argsort()
  positionX = positionX[0,fltr]
  velocityX = velocityX[0,fltr]
  velocityY = velocityy[0,fltr]

  # prepare plot
  fig = plt.figure()
  ax = fig.add_subplot(111)

  # plot energies w.r.t. time
  ax.plot(positionX[0,:], velocityX[0,:], ".-", label="velocity in x")
  ax.plot(positionX[0,:], velocityY[0,:], ".-", label="velocity in y")
  
  # finalize plot
  ax.set_xlabel(r"position $x$ (m)")
  ax.set_ylabel(r"velocity $v$ (m/s)")
  ax.legend()
  
  plt.show()
\end{lstlisting}



% ----------------------------------------------------------------
\section{RuptureHunter}
\label{sec:RuptureHunter}
Tracks ruptures from simulation data.
\begin{lstlisting}
  from ifasha.rupturehunter import RuptureHunter
  hunter = RuptureHunter()
\end{lstlisting}
\subsection{load}
\label{sec:rh:rh:load}
Loads input from the simulation data, using the \hmeth{FieldCollectionAnalysis}.
\begin{lstlisting}
  hunter.load(position, time, stick)
\end{lstlisting}
\begin{itemize}
  \item \param{position}: get data using \hhhmeth{get_field_at_t_index}{fca}{get\_field\_at\_t\_index} at \lcode{idxs = 0}.
  \item \param{time}: get data using \hhhmeth{get_full_field}{fca}{get\_full\_field} and the \lcode{time} \hmeth{FieldId}
  \item \param{stick}: get data using \hmeth{getFullField}{fca}{get\_full\_field} and the \lcode{is_sticking} \hmeth{FieldId}
\end{itemize}
\subsection{hunt}
\label{sec:rh:hunt}
Tracks the ruptures.
\begin{lstlisting}
  hunter.hunt()
\end{lstlisting}
Data has to be loaded before with \hhmeth{load}{rh}.
\subsection{free\_small\_ruptures}
\label{sec:rh:free_small_ruptures}
Deletes all ruptures up to the indicated length.
\begin{lstlisting}
  hunter.free_small_ruptures(max)
\end{lstlisting}
\begin{itemize}
  \item \param{max}: the maximal length of ruptures that are deleted
\end{itemize}
\subsection{free}
\label{sec:rh:free}
Deletes all ruptures given by a set.
\begin{lstlisting}
  hunter.free(rpts)
\end{lstlisting}
\begin{itemize}
  \item \param{rpts}: set of rupture index. 
\end{itemize}
\subsection{renumber}
\label{sec:rh:renumber}
Renumbers the indexes of the ruptures in order to: 1) have continuous rupture indexes, and 2) to start with the first rupture in time and to end with the last rupture in time.
\begin{lstlisting}
  hunter.renumber()
\end{lstlisting}
\subsection{get\_expansions}
\label{sec:rh:get_expansions}
Returns a list of expansion data for all ruptures (sorted in indexes of ruptures)
\begin{lstlisting}
  exps = hunter.get_expansions()
\end{lstlisting}
\begin{itemize}
  \item \param{exps}: list of expansion data for each rupture (sorted w.r.t. the rupture indexes). \lcode{exps[ri,0]} is the smallest and \lcode{exps[ri,1]} the largest position for the rupture of index \lcode{ri}, respectively.
\end{itemize}
\subsection{get\_fronts}
\label{sec:rh:get_fronts}
Returns a list of arrays for sorted (w.r.t. the rupture index) fronts of all ruptures. It is the same order as the rupture indexes given by \hhhmeth{get_rupture_indexes}{rh}{get\_rupture\_indexes}.
\begin{lstlisting}
  fronts = hunter.get_fronts()
\end{lstlisting}
\begin{itemize}
  \item \param{fronts}: list of rupture fronts for all ruptures, sorted w.r.t. to rupture index. A front \lcode{f = fronts[ri]} of rupture with index \lcode{ri} is sorted w.r.t. to the position and is structured as \lcode{f[x,t]} with \lcode{x} the coordinate and \lcode{t} the time.
\end{itemize}
\subsection{get\_backs}
\label{sec:rh:get_backs}
Returns a list of arrays for sorted (w.r.t. the rupture index) backs of all ruptures.  It is the same order as the rupture indexes given by \hhhmeth{get_rupture_indexes}{rh}{get\_rupture\_indexes}.
\begin{lstlisting}
  backs = hunter.get_backs()
\end{lstlisting}
\begin{itemize}
  \item \param{backs}: list of rupture backs for all ruptures, sorted w.r.t. to rupture index. A front \lcode{b = backs[ri]} of rupture with index \lcode{ri} is sorted w.r.t. to the position and is structured as \lcode{b[x,t]} with \lcode{x} the coordinate and \lcode{t} the time.
\end{itemize}
\subsection{get\_rupture\_indexes}
\label{sec:rh:get_rupture_indexes}
Returns a list of the rupture indexes. It is sorted by index.
\begin{lstlisting}
  rptidxs = hunter.get_rupture_indexes()
\end{lstlisting}
\begin{itemize}
  \item \param{rptidxs}: list of rupture indexes sorted by index.
\end{itemize}
\subsection{get\_rupture}
\label{sec:rh:get_rupture}
Returns a rupture for a given index.
\begin{lstlisting}
  rpt = hunter.get_rupture(rptidx)
\end{lstlisting}
\begin{itemize}
  \item \param{rptidx}: index of rupture
  \item \param{rpt}: \hmeth{Rupture}
\end{itemize}

\subsection{Examples}
\label{sec:rh:Examples}

\begin{lstlisting}
  #!/usr/bin/env python

  from ifasha.datamanager import FieldId
  from ifasha.datamanager import FieldCollectionAnalysis
  from ifasha.rupturehunter import RuptureHunter

  import matplotlib.pyplot as plt

  # location of simulation data
  sim_name = "test"
  fc_name = "interface"
  path = "/home/researcher/post_process"

  # load the simulation data
  dma = DataManagerAnalysis(sim_name, path)
  fca = dma.load(fc_name)

  # get position
  index    = fca.get_t_index("first")
  position = fca.get_field_at_t_index(FieldId("position",0),index)

  # get time and stick data
  time  = data.get_full_field(FieldId("time"))
  stick = data.get_full_field(FieldId("is_sticking"))

  # load RuptureHunter and hunt ruptures
  hunter = RuptureHunter()
  hunter.load(position, time, stick)
  hunter.hunt()

  # delete Ruptures that have propagate not further than two position
  hunter.free(2)
  hunter.renumber() # renumber in order to have continuous rupture indexes
  
  # get the expansion of all ruptures
  rptidxs    = hunter.get_rupture_indexes()
  fronts     = hunter.get_fronts()
  backs      = hunter.get_backs()
  expansions = hunter.get_expansions()

  # prepare plot
  fig = plt.figure()
  
  # plot fronts and backs
  ax = fig.add_subplot(211)
  for ft, bk in zip(fronts,backs):
    ax.plot(ft[:,0], ft[:,1], "ko", label="front")
    ax.plot(bk[:,0], bk[:,1], "ro", label="back")
  ax.set_xlabel(r"position $x$")
  ax.set_ylabel(r"time $t$")
  ax.legend()
  
  # plot expansions
  ax = fig.add_subplot(212)
  ax.plot(expansions[:,0], rptidxs, "bo", label="min")
  ax.plot(expansions[:,1], rptidxs, "go", label="max")
  ax.set_xlabel(r"position $x$")
  ax.set_ylabel(r"rupture index")
  ax.legend()

  plt.show()
\end{lstlisting}



% ----------------------------------------------------------------

% \addcontentsline{toc}{section}{Bibliography}
% \bibliographystyle{ieeetr}
% \bibliography{local_bib}

\end{document}
